# Paths
SNITCH_SW_PATH = "/opt/snax-mac"
SNITCH_LLVM_PATH = "/usr/bin"

# Binaries
VLTSIM = "/opt/snax-mac-rtl/bin/snitch_cluster.vlt"
CC = f"{SNITCH_LLVM_PATH}/clang"
LD = CC
MLIROPT = "mlir-opt"
MLIRTRANSLATE = "mlir-translate"
SNAXOPT = "snax-opt"

# Flags
CFLAGS = [
    "-Wno-unused-command-line-argument",
    f"-I{SNITCH_SW_PATH}/target/snitch_cluster/sw/runtime/rtl-generic/src",
    f"-I{SNITCH_SW_PATH}/target/snitch_cluster/sw/runtime/common",
    f"-I{SNITCH_SW_PATH}/sw/snRuntime/api",
    f"-I{SNITCH_SW_PATH}/sw/snRuntime/src",
    f"-I{SNITCH_SW_PATH}/sw/snRuntime/src/omp/",
    f"-I{SNITCH_SW_PATH}/sw/snRuntime/api/omp/",
    f"-I{SNITCH_SW_PATH}/sw/math/arch/riscv64/bits/",
    f"-I{SNITCH_SW_PATH}/sw/math/arch/generic",
    f"-I{SNITCH_SW_PATH}/sw/math/src/include",
    f"-I{SNITCH_SW_PATH}/sw/math/src/internal",
    f"-I{SNITCH_SW_PATH}/sw/math/include/bits",
    f"-I{SNITCH_SW_PATH}/sw/math/include",
    f"-I../../runtime/include",
    "-D__DEFINED_uint64_t",
    "--target=riscv32-unknown-elf",
    "-mcpu=generic-rv32",
    "-march=rv32imafdzfh",
    "-mabi=ilp32d",
    "-mcmodel=medany",
    "-ftls-model=local-exec",
    "-ffast-math",
    "-fno-builtin-printf",
    "-fno-common",
    "-O3",
]
CFLAGS.extend(["-std=gnu11", "-Wall", "-Wextra"])


LDFLAGS = [
    f"-fuse-ld={SNITCH_LLVM_PATH}/ld.lld",
    "--target=riscv32-unknown-elf",
    "-mcpu=generic-rv32",
    "-march=rv32imafdzfh",
    "-mabi=ilp32d",
    "-mcmodel=medany",
    f"-T{SNITCH_SW_PATH}/sw/snRuntime/base.ld",
    f"-L{SNITCH_SW_PATH}/target/snitch_cluster/sw/runtime/rtl-generic",
    f"-L{SNITCH_SW_PATH}/target/snitch_cluster/sw/runtime/rtl-generic/build",
    "-nostdlib",
    "-lsnRuntime",
]


MLIRPREPROCFLAGS = [
    "--pass-pipeline='builtin.module(func.func(tosa-to-linalg-named, tosa-to-tensor, tosa-to-scf, tosa-to-linalg))'",
    "--mlir-print-op-generic",
    "--mlir-print-local-scope",
]

MLIRPREPROC2FLAGS = [
    "--tosa-to-arith='include-apply-rescale'",
    "--empty-tensor-to-alloc-tensor",
]

MLIRPREPROC3FLAGS = [
    "--test-linalg-transform-patterns='test-generalize-pad-tensor'",
    "--linalg-generalize-named-ops",
    "--empty-tensor-to-alloc-tensor --one-shot-bufferize='bufferize-function-boundaries allow-return-allocs-from-loops function-boundary-type-conversion=identity-layout-map'",
    "--mlir-print-op-generic",
    "--mlir-print-local-scope",
]

MLIROPTFLAGS = [
    "--convert-linalg-to-loops",
    "--convert-scf-to-cf",
    "--lower-affine",
    "--canonicalize",
    "--cse",
    "--convert-math-to-llvm",
    "--llvm-request-c-wrappers",
    "--expand-strided-metadata",
    "--lower-affine",
    "--convert-index-to-llvm=index-bitwidth=32",
    "--convert-cf-to-llvm=index-bitwidth=32",
    "--convert-arith-to-llvm=index-bitwidth=32",
    "--convert-func-to-llvm='index-bitwidth=32'",
    "--finalize-memref-to-llvm='use-generic-functions index-bitwidth=32'",
    "--canonicalize",
    "--reconcile-unrealized-casts",
]


SNAXOPTFLAGS = [
    "dispatch-kernels",
    "set-memory-space",
    "set-memory-layout",
    "realize-memref-casts",
    "reuse-memref-allocs",
    "insert-sync-barrier",
    "dispatch-regions",
    "linalg-to-library-call",
    "snax-copy-to-dma",
    "memref-to-snax",
    "snax-to-func",
    "clear-memory-space",
]
SNAXOPTFLAGS = ",".join(SNAXOPTFLAGS)

# Rules


rule all:
    input:
        "simple_copy.x",


rule generate_data:
    output:
        "data.c",
        "data.h",
    script:
        "gendata.py"


rule postprocess_llvm_module:
    input:
        "{file}.ll",
    output:
        temp("{file}.ll12"),
    shell:
        "../../runtime/tollvm12.py < {input} > {output} "


rule compile_llvm_module:
    input:
        "{file}.ll12",
    output:
        temp("{file}.o"),
    shell:
        "{CC} {CFLAGS} -x ir -c {input} -o {output}"


rule compile_main:
    input:
        "data.o",
        "main.c",
    output:
        temp("main.o"),
    shell:
        "{CC} {CFLAGS} -c {input} -o {output}"


rule compile_snax_binary:
    input:
        "main.o",
        "data.o",
        "simple_copy.o",
    output:
        "simple_copy.x",
    shell:
        "{LD} {LDFLAGS} {input} -o {output}"


rule compile_c:
    input:
        "{file}.c",
    output:
        temp("{file}.o"),
    shell:
        "{CC} {CFLAGS} -c {input} -o {output}"


rule rtl_simulation:
    input:
        "simple_copy.x",
    output:
        "logs/trace_chip_00_hart_00000.dasm",
        "logs/trace_chip_00_hart_00001.dasm",
    shell:
        "{VLTSIM} {input}"


rule clean:
    shell:
        "rm -rf *.ll12 *.x *.o *.logs/ logs/ data.h data.c"


rule preprocess_mlir:
    input:
        "{file}.mlir",
    output:
        temp("{file}.preproc1.mlir"),
        temp("{file}.preproc2.mlir"),
        temp("{file}.preprocfinal.mlir"),
    run:
        shell("{MLIROPT} {MLIRPREPROCFLAGS} -o {wildcards.file}.preproc1.mlir {input}")
        shell(
            "{MLIROPT} {MLIRPREPROC2FLAGS} -o {wildcards.file}.preproc2.mlir {wildcards.file}.preproc1.mlir"
        )
        shell(
            "{MLIROPT} {MLIRPREPROC3FLAGS} -o {output[2]} {wildcards.file}.preproc2.mlir"
        )


rule snax_opt_mlir:
    input:
        "{file}.preprocfinal.mlir",
    output:
        temp("{file}.snax-opt.mlir"),
    shell:
        "{SNAXOPT} -p {SNAXOPTFLAGS} -o {output} {input}"


rule translate_mlir:
    input:
        "{file}.ll.mlir",
    output:
        temp("{file}.ll"),
    shell:
        "{MLIRTRANSLATE} --mlir-to-llvmir -o {output} {input}"


rule postprocess_mlir:
    input:
        "{file}.snax-opt.mlir",
    output:
        temp("{file}.ll.mlir"),
    shell:
        "{MLIROPT} {MLIROPTFLAGS} -o {output} {input}"
