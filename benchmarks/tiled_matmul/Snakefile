from util.snake.flags import (
    get_cc_flags,
    get_ld_flags,
    get_mlir_postproc_flags,
    get_mlir_preproc_flags,
)
from util.snake.paths import get_default_paths

# Paths
SNITCH_SW_PATH = "/opt/snax-streamer-gemm"
SNITCH_LLVM_PATH = "/usr/bin"
VLTSIM = "/opt/snax-streamer-gemm-rtl/bin/snitch_cluster.vlt"

(
    config["cc"],
    config["ld"],
    config["mlir-opt"],
    config["mlir-translate"],
    config["snax-opt"],
) = get_default_paths(SNITCH_LLVM_PATH)

# Flags
config["cflags"] = [
    *get_cc_flags(SNITCH_SW_PATH),
    "-std=gnu11",
    "-Wall",
    "-Wextra",
    f"-I{SNITCH_SW_PATH}/target/snitch_cluster/sw/snax/streamer-gemm/include",
]

config["ldflags"] = [
    *get_ld_flags(SNITCH_LLVM_PATH, SNITCH_SW_PATH),
    f"{SNITCH_SW_PATH}/target/snitch_cluster/sw/snax/streamer-gemm/build/snax-streamer-gemm-lib.o",
]

config["mlirpreprocflags"], config["mlirpreproc2flags"], config["mlirpreproc3flags"] = (
    get_mlir_preproc_flags()
)
config["mlirpostprocflags"] = get_mlir_postproc_flags()


def get_snax_opt_flags(options):
    flags = []
    match options:
        case "deduponly":
            flags = ["accfg-dedup"]
        case "overlaponly":
            flags = ["accfg-config-overlap"]
        case "accfgboth":
            flags = ["accfg-dedup", "accfg-config-overlap"]
    return ",".join(
        [
            "insert-accfg-op{accelerator=snax_gemm}",
            "convert-linalg-to-kernel",
            "dispatch-kernels",
            "set-memory-space",
            "set-memory-layout",
            "realize-memref-casts",
            "test-remove-memref-copy",
            "insert-sync-barrier",
            "reuse-memref-allocs",
            "test-add-mcycle-around-loop",
            "snax-lower-mcycle",
            "dispatch-regions",
            "convert-linalg-to-stream",
            "convert-stream-to-snax-stream",
            "convert-linalg-to-accfg",
            "snax-copy-to-dma",
            "memref-to-snax",
            "snax-to-func",
            "clear-memory-space",
            "function-constant-pinning",
            "mlir-opt{"
            + "\ ".join(
                [
                    "executable=mlir-opt",
                    "generic=true",
                    "arguments='"
                    + ",".join(
                        [
                            "-cse",
                            "-canonicalize",
                            "-allow-unregistered-dialect",
                            "-mlir-print-op-generic",
                        ]
                    ),
                ]
            )
            + "'}",
            *flags,
            "convert-accfg-to-csr",
        ]
    )


sizes = [
    [16, 16, 16],
    [32, 32, 32],
    [64, 64, 64],
    [128, 128, 128],
    [256, 256, 256],
    [512, 512, 512],
]

options = [
    "noaccfgopt",
    "deduponly",
    "overlaponly",
    "accfgboth",
]

tiling_factors = [[8, 8]]

from genbenchmark import create_tiled_matrix_multiply, write_module_to_file
from gendata import create_test_data


module default_rules:
    snakefile:
        "../../util/snake/default_rules.smk"
    config:
        config


use rule * from default_rules as default_*


# Rules
rule run_benchmarks:
    input:
        expand(
            "generated_{size[0]}_{size[1]}_{size[2]}_{options}.x",
            size=sizes,
            options=options,
        ),


rule generate_mlir:
    output:
        "generated_{m}_{n}_{k}.generated.mlir",
    params:
        k=lambda wildcards: int(wildcards.k),
        m=lambda wildcards: int(wildcards.m),
        n=lambda wildcards: int(wildcards.n),
        # hardcoded to [8,8] for now
        tiling_factors=lambda _: tiling_factors[0],
    run:
        write_module_to_file(
            create_tiled_matrix_multiply(
                params.k, params.m, params.n, params.tiling_factors
            ),
            output[0],
        )


rule preprocess_mlir:
    input:
        "{file}.generated.mlir",
    output:
        temp("{file}.preproc1.mlir"),
        temp("{file}.preproc2.mlir"),
        temp("{file}.preprocfinal.mlir"),
    run:
        shell(
            "{config[mlir-opt]} {config[mlirpreprocflags]} -o {wildcards.file}.preproc1.mlir {input}"
        )
        shell(
            "{config[mlir-opt]} {config[mlirpreproc2flags]} -o {wildcards.file}.preproc2.mlir {wildcards.file}.preproc1.mlir"
        )
        shell(
            "{config[mlir-opt]} {config[mlirpreproc3flags]} -o {output[2]} {wildcards.file}.preproc2.mlir"
        )


rule snax_opt_mlir:
    input:
        "generated_{m}_{n}_{k}.preprocfinal.mlir",
    output:
        temp("generated_{m}_{n}_{k}_{options}.snax-opt.mlir"),
    params:
        snax_flags=lambda wildcards: get_snax_opt_flags(wildcards.options),
    shell:
        "{SNAXOPT} -p {params.snax_flags} -o {output} {input}"


rule generate_data:
    output:
        "data_{m}_{n}_{k}.c",
        "data_{m}_{n}_{k}.h",
    run:
        create_test_data(wildcards.n, wildcards.m, wildcards.k)


rule compile_main:
    input:
        "data_{m}_{n}_{k}.o",
        "main.c",
    output:
        temp("main_{m}_{n}_{k}.o"),
    shell:
        "{config[cc]} {config[cflags]} -c {input} -o {output}"


rule compile_snax_binary:
    input:
        "generated_{m}_{n}_{k}_{options}.o",
        "main_{m}_{n}_{k}.o",
        "data_{m}_{n}_{k}.o",
    output:
        "generated_{m}_{n}_{k}_{options}.x",
    shell:
        "{config[ld]} {config[ldflags]} {input} -o {output}"


rule rtl_simulation:
    input:
        "{file}.x",
    output:
        "logs/trace_chip_{numchips}_hart_{hartid}.dasm",
    shell:
        "{VLTSIM} {input}"


rule clean:
    shell:
        "rm -rf *.ll12 *.x *.o *.logs/ logs/ data*"
