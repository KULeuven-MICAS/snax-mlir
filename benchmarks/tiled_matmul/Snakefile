from util.snake.flags import get_default_flags
from util.snake.paths import get_default_paths

# Paths
SNITCH_SW_PATH = "/opt/snax-streamer-gemm"

config.update(get_default_paths())
config.update(get_default_flags(SNITCH_SW_PATH))
config["vltsim"] = "/opt/snax-streamer-gemm-rtl/bin/snitch_cluster.vlt"
config["cflags"].append(
    f"-I{SNITCH_SW_PATH}/target/snitch_cluster/sw/snax/streamer-gemm/include"
)
config["ldflags"].append(
    f"{SNITCH_SW_PATH}/target/snitch_cluster/sw/snax/streamer-gemm/build/snax-streamer-gemm-lib.o"
)


def get_snax_opt_flags(options):
    flags = []
    match options:
        case "deduponly":
            flags = ["accfg-dedup"]
        case "overlaponly":
            flags = ["accfg-config-overlap"]
        case "accfgboth":
            flags = ["accfg-dedup", "accfg-config-overlap"]
    return ",".join(
        [
            "insert-accfg-op{accelerator=snax_gemm}",
            "convert-linalg-to-kernel",
            "dispatch-kernels",
            "set-memory-space",
            "set-memory-layout",
            "realize-memref-casts",
            "test-remove-memref-copy",
            "insert-sync-barrier",
            "reuse-memref-allocs",
            "test-add-mcycle-around-loop",
            "snax-lower-mcycle",
            "dispatch-regions",
            "convert-linalg-to-stream",
            "convert-stream-to-snax-stream",
            "convert-linalg-to-accfg",
            "snax-copy-to-dma",
            "memref-to-snax",
            "snax-to-func",
            "clear-memory-space",
            "function-constant-pinning",
            "mlir-opt{"
            + "\ ".join(
                [
                    "executable=mlir-opt",
                    "generic=true",
                    "arguments='"
                    + ",".join(
                        [
                            "-cse",
                            "-canonicalize",
                            "-allow-unregistered-dialect",
                            "-mlir-print-op-generic",
                        ]
                    ),
                ]
            )
            + "'}",
            *flags,
            "convert-accfg-to-csr",
        ]
    )


sizes = [
    [16, 16, 16],
    [32, 32, 32],
    [64, 64, 64],
    [128, 128, 128],
    [256, 256, 256],
    [512, 512, 512],
]

options = [
    "noaccfgopt",
    "deduponly",
    "overlaponly",
    "accfgboth",
]

tiling_factors = [[8, 8]]

from genbenchmark import create_tiled_matrix_multiply, write_module_to_file
from gendata import create_test_data


module default_rules:
    snakefile:
        "../../util/snake/default_rules.smk"
    config:
        config


use rule * from default_rules exclude snax_opt_mlir, generate_simple_data, compile_simple_main as default_*


# Rules
rule run_benchmarks:
    input:
        expand(
            "generated_{size[0]}_{size[1]}_{size[2]}_{options}.x",
            size=sizes,
            options=options,
        ),


rule generate_mlir:
    output:
        "generated_{m}_{n}_{k}.generated.mlir",
    params:
        k=lambda wildcards: int(wildcards.k),
        m=lambda wildcards: int(wildcards.m),
        n=lambda wildcards: int(wildcards.n),
        # hardcoded to [8,8] for now
        tiling_factors=lambda _: tiling_factors[0],
    run:
        write_module_to_file(
            create_tiled_matrix_multiply(
                params.k, params.m, params.n, params.tiling_factors
            ),
            output[0],
        )


rule snax_opt_mlir:
    input:
        "generated_{m}_{n}_{k}.preprocfinal.mlir",
    output:
        temp("generated_{m}_{n}_{k}_{options}.snax-opt.mlir"),
    params:
        snax_flags=lambda wildcards: get_snax_opt_flags(wildcards.options),
    shell:
        "{SNAXOPT} -p {params.snax_flags} -o {output} {input}"


rule generate_data:
    output:
        "data_{m}_{n}_{k}.c",
        "data_{m}_{n}_{k}.h",
    run:
        create_test_data(wildcards.n, wildcards.m, wildcards.k)


rule compile_main:
    input:
        "data_{m}_{n}_{k}.o",
        "main.c",
    output:
        temp("main_{m}_{n}_{k}.o"),
    shell:
        "{config[cc]} {config[cflags]} -c {input} -o {output}"


rule compile_snax_binary:
    input:
        "generated_{m}_{n}_{k}_{options}.o",
        "main_{m}_{n}_{k}.o",
        "data_{m}_{n}_{k}.o",
    output:
        "generated_{m}_{n}_{k}_{options}.x",
    shell:
        "{config[ld]} {config[ldflags]} {input} -o {output}"
