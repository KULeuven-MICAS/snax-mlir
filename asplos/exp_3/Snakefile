from util.snake.configs import get_asplos_matmul_config
from util.snake.configs import get_asplos_matvec_config

import os

config_matmul = get_asplos_matmul_config()

config = get_asplos_matmul_config()


module snax_rules:
    snakefile:
        "../../util/snake/snax.smk"
    config:
        config


use rule * from snax_rules exclude snax_opt_mlir, simulate as snax_*


tests = ["conv"]
systems = ["2", "3", "4", "5", "6", "8"]
layout = ["default", "cyclic", "banked"]
channels = [64, 72, 80, 96]


rule all:
    input:
        "summary.txt"

rule extract_cycles:
    input:
        expand("{file}_channel{channel}_layout{layout}_sys{sys}_traces.json", file=tests, channel=channels, layout=layout, sys=systems),
    output:
        "summary.txt",
    shell:
        "python extract_cycles.py {output} {input}"


rule simulate:
    input:
        "{file}.x",
    output:
        temp(
            expand(
                "{file}_sys{sys}_trace_chip_{num_chips:02d}_hart_{num_harts:05d}.dasm",
                file=["{file}"],
                sys=["{sys}"],
                num_chips=range(config["num_chips"]),
                num_harts=range(config["num_harts"]),
            ),
        ),
    log:
        "{file}_sys{sys}.vltlog",
    params:
        vltsim=lambda wildcards: (
            os.environ["CONDA_PREFIX"] + "/snax-utils" + f"/asplos_matmul_{wildcards.sys}-rtl/bin/snitch_cluster.vlt"
        ),
    shell:
        "{params.vltsim} --prefix-trace={wildcards.file}_sys{wildcards.sys}_ {input}  2>&1 | tee {log}"


# # matmul of 64x64x64
# rule generate_matmul:
#     output:
#         "matmul_sys{sys}.mlir",
#     wildcard_constraints:
#         sys="|".join(systems),
#     shell:
#         "python matmul.py --m 64 --n 64 --k 64 --output {output}"
# 
# 
# # matvec of 1x256x256
# rule generate_matvec:
#     output:
#         "matvec_sys{sys}.mlir",
#     params:
#         # for matmul, op should be padded to fill array for successful compilation
#         m=lambda wildcards: 1 if wildcards.sys == "vec" else 8,
#     wildcard_constraints:
#         sys="|".join(systems),
#     shell:
#         "python matmul.py --m {params.m} --n 256 --k 256 --output {output}"
# 
# 
# # early conv: only 3 input channels (other params are tiled such that they fit L1 memory)
# # c = 3, k = 16, ox = 16, oy = 16, fx = 3, fy = 3
# rule generate_earlyconv:
#     output:
#         "earlyconv_sys{sys}.mlir",
#     params:
#         # pad the conv from C=3 to fit the array properly
#         c=lambda wildcards: 32 if wildcards.sys == "vec" else 8,
#     wildcard_constraints:
#         sys="|".join(systems),
#     shell:
#         "python conv.py --c {params.c} --k 16 --ox 16 --oy 16 --output {output}"


# late conv: all params are pretty large except for limited feature map of 8x8,
# tiled to sensible values for L1
# ox = 8, oy = 8, fx = 3, fy = 3, c = 32, k = 32
rule generate_conv:
    output:
        "conv_channel{channel}.mlir",
    wildcard_constraints:
        channel="|".join([str(channel) for channel in channels]),
    shell:
        "python conv.py --c {wildcards.channel} --k 72 --ox 72 --oy 1 --output {output}"


rule compile_snax:
    input:
        "{file}.mlir",
    output:
        temp("{file}_layout{layout}.ll.mlir"),
    shell:
        "{config[snaxc]} -c {config[snaxc-config]} --ignore-transforms --asplos-exp3-idx 0 --layout {wildcards.layout} --add-mcycle -o {output} {input}"


def get_linked_files(wildcards):
    if "conv" in wildcards.file:
        return [f"{wildcards.file}.o", "main_4d_i8.o"]
    else:
        return [f"{wildcards.file}.o", "main_2d_i8.o"]


rule link_snax_binary:
    input:
        get_linked_files,
    output:
        "{file}.x",
    shell:
        "{config[ld]} {config[ldflags]} {input} -o {output}"
